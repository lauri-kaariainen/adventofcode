<body><pre>check console</pre></body>
<script>

"use strict"




const input = 
`amgozmfv`;


const testInput = 
`flqrgnkx`;


const hex2bin = hex =>
	("0000" + (parseInt(hex, 16)).toString(2)).substr(-4);



const knotHash = (str) =>{

	const specialValuesForB =
	    [17, 31, 73, 47, 23];
	const array = [...new Array(256)].map((e,i)=>i);

	const lengths = str.split("")
	    .map(char=>char.charCodeAt(0))
	    .concat(specialValuesForB);
	
	const recursivelySolveList = (array,lengthList,step,skipSize,currPos) => {
	    step = step || 0;
	    skipSize = skipSize || 0;
	    currPos = currPos || 0;
	    
	    array = [...array];
	    if(step >= lengthList.length) 
	        return {
	            "array":array,
	            "skipSize":skipSize,
	            "currPos":currPos,
	        };
	    if(currPos >= array.length)
	        currPos = currPos % array.length;
	    
	    const currLength = lengthList[step];
	    if(currLength === 1 || currLength === 0){

	    }
	    else if(array.length - currPos - currLength >= 0){

	        array.splice(
	            currPos,
	            0,
	            ...array.slice(currPos,currLength+currPos).reverse());

	        array.splice(
	            currPos+currLength,
	            currLength);

	    }
	    else{
	        const cutOutSlice =
	            array
	                .slice(currPos)
	                .concat(
	                    array.slice(0,currLength - (array.length-currPos)));
	        
	        const startSliceLength = 
	            currLength - (array.length-currPos);

	        const endSliceLength =
	            array.length-currPos;
	        
	        const newStartSlice = 
	            [...cutOutSlice] //NOTE that reverse() mutates!
	                .reverse()
	                .slice(0,currLength - (array.length-currPos))
	        
	        const newEndSlice =
	            [...cutOutSlice] //NOTE thatreverse() mutates!
	                .reverse()
	                .slice(-endSliceLength)

	        cutOutSlice.reverse()
	            .forEach((snum,i)=>
	                array[currPos+i] !== undefined ? (array[currPos+i] = snum):
	                                            (array[currPos+i-array.length] = snum)) 

	    }

	    return recursivelySolveList(
	            array,
	            lengthList,
	            step+1,
	            skipSize+1,
	            parseInt(currPos)+parseInt(currLength)+parseInt(skipSize));

	}
	const recursivelySolveB = (input,LENGTHSForB,skippedSize,currPosition,runTimes) =>{
	    skippedSize = skippedSize || 0;
	    currPosition = currPosition || 0;
	    runTimes = runTimes || 0;
	    if(runTimes >= 64)
	        return input;
	    const {array,skipSize,currPos} = 
	        recursivelySolveList(
	            input,
	            LENGTHSForB,
	            0,
	            skippedSize,
	            currPosition);

	    return recursivelySolveB(array,LENGTHSForB,skipSize,currPos,runTimes+1);
	}
	const resultB = 
	    recursivelySolveB(array,lengths,0,0,0)
	const splitInto16Parts = 
	    resultB
	        .reduce((acc,next,i)=>
	            acc[acc.length-1].length % 16 === 0 ? acc.concat([[next]]) : 
	                                                  (acc[acc.length-1].push(next),acc)  
	            ,[[]])
	        .slice(1);


	return splitInto16Parts
	    .map(lineOfNums=>lineOfNums.reduce((a,b)=>a^b,0))
	    .map(num=>num.toString(16))
	    .map(term=>term.length > 1 ? term : "0"+term.toString())
	    //doesn't work without this? why?
	    .join("")
	    .split("")
	    .map(n=>hex2bin(n))
	    .join("")

}
const collectGrid = (inputStr) =>{
	let total = [];
	for(let i = 0; i < 128;i++)
		total.push(knotHash(inputStr+"-"+i.toString()))
	return total;
}

// const find4 = (x,y,arrayOfArrays,wantedChar) => {
// 	wantedChar = wantedChar || 1;
// 	let returnable = [];
// 	if(x > 0 && x < arrayOfArrays[y].length-1){
// 		arrayOfArrays[y][x-1] === wantedChar ? returnable.push({x:x-1,y:y}):false;
// 		arrayOfArrays[y][x+1] === wantedChar ? returnable.push({x:x+1,y:y}):false;
// 	}
// 	else if(x === 0){
// 		arrayOfArrays[y][x+1] === wantedChar ? returnable.push({x:x+1,y:y}):false;
// 	}
// 	else if(x === arrayOfArrays[y].length - 1){
// 		arrayOfArrays[y][x-1] === wantedChar ? returnable.push({x:x-1,y:y}):false;	
// 	}
// 	if(y > 0 && y < arrayOfArrays.length-1){
// 		arrayOfArrays[y+1][x] === wantedChar ? returnable.push({x:x,y:y+1}):false;
// 		arrayOfArrays[y-1][x] === wantedChar ? returnable.push({x:x,y:y-1}):false;
// 	}
// 	else if(y === 0){
// 		arrayOfArrays[y+1][x] === wantedChar ? returnable.push({x:x,y:y+1}):false;
// 	}
// 	else if(y === arrayOfArrays.length-1){
// 		arrayOfArrays[y-1][x] === wantedChar ? returnable.push({x:x,y:y-1}):false;
// 	}
// 	return returnable;
// }

// const numToLetter =chr =>  
// 	String.fromCharCode(97 + chr);

const theGrid = 
	collectGrid(input)
		.map(line=>line.split(""));

console.log(
	"A:",
	theGrid
		.map(line=>line.reduce((acc,next)=>acc+parseInt(next),0))
		.reduce((acc,next)=>acc+next,0)
	)


const calculateGroups = (grid) =>{

	
	const flatObjectMap =
		grid
			.map((numArray,y)=>numArray.map((num,x)=>(num === "1" ? {x:x,y:y}:false)).filter(e=>e))
			.reduce((acc,next)=>acc.concat(next),[])


	const handleCompare = (newObj,currObj) =>
		((newObj.x === currObj.x && (newObj.y === (currObj.y+1) || newObj.y === (currObj.y-1))) ||
		(newObj.y === currObj.y && (newObj.x === currObj.x+1 || newObj.x === currObj.x-1)))


	
	const recursivelyFindNeighbors = (step,objectList,groupList,currGroup,ignoreGroup) =>() =>{
		
		const newIgnoreGroup = 
			ignoreGroup
				.concat(currGroup)
				.filter((obj,i,arr)=>!arr.slice(i+1).some(otherObj=>otherObj.x===obj.x&&otherObj.y===obj.y));

		if(!objectList.length)
			return groupList;
		const otherElems =
			currGroup
				.filter(currObj=>!ignoreGroup.some(obj=>obj.x===currObj.x&&obj.y===currObj.y))
				.map(currObj=>
					objectList.filter(obj=>handleCompare(obj,currObj)))
				.reduce((acc,next)=>acc.concat(next),[])
				.filter(o=>o);

		if(step % 5 === 0)
			console.log(
				"left:",
				objectList.length,
				"gathered so far:",
				groupList.length,
				"newIgnoreGroup:",
				newIgnoreGroup.length,
				"currGroup:",
				currGroup.length);


		if(otherElems.length){

			const newObjectList =
				objectList
					.filter(curr=>
							!otherElems
								.some(otherObj=>(otherObj.x===curr.x && otherObj.y===curr.y)))

			return recursivelyFindNeighbors(
				step+1,
				newObjectList,
				groupList,
				currGroup
					.concat(otherElems)
					.filter((obj,i,arr)=>
						!arr.slice(i+1).some(otherObj=>otherObj.x===obj.x&&otherObj.y===obj.y)),
				newIgnoreGroup)
		}
		else {
			const newGroupList =groupList.concat([currGroup]);
			return recursivelyFindNeighbors(
				step+1,
				objectList.slice(1),
				newGroupList,
				[objectList[0]],
				[])	
		}

	}

	return trampoline(
		recursivelyFindNeighbors(
			0,
			flatObjectMap.slice(1),
			[],
			[flatObjectMap[0]],
			[])
	)




}
const trampoline = (fn) => {
    while (typeof fn === 'function') {
        fn = fn();
    }
    return fn;
};

console.log(
	calculateGroups(theGrid).length+1
	)

</script>
