{"mappings":"eAISA,KAAOC,GACa,oBAAbC,SAAkD,oBAAdC,WAC5CD,QAAQE,OAAOH,GACfE,SAASE,cAAc,OAAQC,WAAa,QAAUL,EAAKM,KAAK,MANxEL,QAAQE,IAAII,IAAWC,QACvBP,QAAQE,IAAIM,IAAeD,QASIC,IAA/B,MACMC,EAAqBH,IAYrBI,EAAc,CAAIC,EAAgBC,EAAkBC,EAAc,KACpE,MAAMC,EAAgC,GAGtC,OAFID,EAAM,IAAO,GACbb,QAAQE,IAAIW,EAAK,IAAKF,EAAKJ,QAC3BM,GAAOD,EACAD,EACJD,EACHC,EACKI,KAAKC,GACFA,EAAc,EAAIA,EAAc,GAC3BF,EAAoBG,KAAK,GAAI,KACrCC,OAAOJ,GACZF,EACAC,EAAM,IAGRM,EAAkB,CACpBC,EACAR,EACAC,EAAc,KAGd,GAFIA,EAAM,IAAO,GACbb,QAAQE,IAAIW,EAAK,IAAKQ,KAAKC,UAAUF,IACrCP,GAAOD,EACP,OAAOQ,EACX,MAAMG,EAAgBH,EAAQ,GAS9B,OARAI,OAAOC,KAAKL,GACPM,SAAO,CAAEC,EAAaC,IACb,IAANA,EACIR,EAAQ,GAAKA,EAAQO,GACrBP,EAAQ,IAAMS,SAASF,GAAO,IAAMP,EAAQO,KAExDP,EAAQ,GAAKG,EACbH,EAAQ,IAAMA,EAAQ,GACfD,EACHC,EACAR,EACAC,EAAM,IAKRiB,EAAWrB,EAEjBX,EAAI,KACAY,EAEIoB,EACKzB,KAAK,MACL0B,MAAM,KACNhB,KAAKiB,GAAsBH,SAASG,KACzC,IACFzB,QAIN,MAAM0B,EAEEH,EACKzB,KAAK,MACL0B,MAAM,KACNhB,KAAKiB,GAAsBH,SAASG,KC4FzCE,QAAM,CAAEC,EAAKC,KACjBD,EAAIC,QAAoBC,IAAbF,EAAIC,GAAqB,EAAID,EAAIC,IAAQ,EAC7CD,IACN,aD7EI3B,IACL,MAAM,YACUuB,MAAM,eAGjBzB,IACL,MAAM,0lBAEwlByB,MAAM,MAzBxmBE,EAAQ,GAAK,EACbA,EAAQ,GAAK,EACbA,EAAQ,GAAK,EACbA,EAAQ,GAAK,EAGbnC,EAAI,KACA0B,OAAOc,OAEHnB,EACIc,EACA,MAEHC,QAAM,CAAEC,EAAaI,IAAsBJ,EAAMI,GAAM","sources":["src/index.ts","../../helpmodule.js"],"sourcesContent":["import { returnUniqueAmountsAsObj } from \"../../../helpmodule.js\";\r\nconsole.log(getInput().length);\r\nconsole.log(getTESTInput().length);\r\n\r\nfunction log(...args: any[]): void {\r\n    if (typeof (console) !== 'undefined' && typeof (document) !== 'undefined') {\r\n        console.log(...args);\r\n        document.querySelector('pre')!.innerHTML += \"<br/>\" + args.join(\" \");\r\n    }\r\n}\r\n\r\nconst testInputArr: string[] = getTESTInput();\r\nconst inputArr: string[] = getInput();\r\n\r\n\r\n\r\n// const parseInput = (arr: string[]): { origin: { x: number, y: number }, target: { x: number, y: number } }[] =>\r\n//     arr.map((line: string) => {\r\n//         const matches = line.match(/(\\d+),(\\d+) -> (\\d+),(\\d+)/)\r\n//         return ({\r\n//             origin: { x: parseInt(matches![1]), y: parseInt(matches![2]) },\r\n//             target: { x: parseInt(matches![3]), y: parseInt(matches![4]) },\r\n//         })\r\n//     })\r\nconst advanceNumDays = (list: number[], dayLimit: number, day: number = 0): number[] | Function => {\r\n    const newChildrenMutating: number[] = [];\r\n    if (day % 10 === 0)\r\n        console.log(day, \":\", list.length)\r\n    if (day >= dayLimit)\r\n        return list;\r\n    return advanceNumDays(\r\n        list\r\n            .map((lanternfish: number): number =>\r\n                lanternfish > 0 ? lanternfish - 1 :\r\n                    (newChildrenMutating.push(8), 6))\r\n            .concat(newChildrenMutating),\r\n        dayLimit,\r\n        day + 1\r\n    )\r\n}\r\nconst advanceNumDaysForB = (\r\n    listObj: any, // = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0 },\r\n    dayLimit: number,\r\n    day: number = 0): any | Function => {\r\n    if (day % 10 === 0)\r\n        console.log(day, \":\", JSON.stringify(listObj))\r\n    if (day >= dayLimit)\r\n        return listObj;\r\n    const tempValueFor8 = listObj[8]\r\n    Object.keys(listObj)\r\n        .forEach((key: string, i: number): any =>\r\n            i === 0 ?\r\n                listObj[8] = listObj[key] :\r\n                listObj[\"\" + (parseInt(key) - 1)] = listObj[key])\r\n\r\n    listObj[7] = tempValueFor8;\r\n    listObj[6] += listObj[8]\r\n    return advanceNumDaysForB(\r\n        listObj,\r\n        dayLimit,\r\n        day + 1\r\n    )\r\n}\r\n\r\n\r\nconst arrInUse = inputArr;\r\n\r\nlog(\"a:\",\r\n    advanceNumDays(\r\n\r\n        arrInUse\r\n            .join(\"\\n\")\r\n            .split(\",\")\r\n            .map((e: string): number => parseInt(e)),\r\n        80\r\n    ).length\r\n)\r\n\r\n\r\nconst objForB =\r\n    returnUniqueAmountsAsObj(\r\n        arrInUse\r\n            .join(\"\\n\")\r\n            .split(\",\")\r\n            .map((e: string): number => parseInt(e)))\r\nobjForB[0] = 0;\r\nobjForB[6] = 0;\r\nobjForB[7] = 0;\r\nobjForB[8] = 0;\r\n\r\n\r\nlog(\"b:\",\r\n    Object.values(\r\n\r\n        advanceNumDaysForB(\r\n            objForB,\r\n            256\r\n        ))\r\n        .reduce((acc: number, next: any): number => acc + next, 0)\r\n)\r\n\r\n\r\nfunction getTESTInput(): string[] {\r\n    return (\r\n        `3,4,3,1,2`.split(\"\\n\"))\r\n}\r\n\r\nfunction getInput(): string[] {\r\n    return (\r\n\r\n        `4,1,1,4,1,2,1,4,1,3,4,4,1,5,5,1,3,1,1,1,4,4,3,1,5,3,1,2,5,1,1,5,1,1,4,1,1,1,1,2,1,5,3,4,4,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,5,1,1,1,4,1,2,3,5,1,2,2,4,1,4,4,4,1,2,5,1,2,1,1,1,1,1,1,4,1,1,4,3,4,2,1,3,1,1,1,3,5,5,4,3,4,1,5,1,1,1,2,2,1,3,1,2,4,1,1,3,3,1,3,3,1,1,3,1,5,1,1,3,1,1,1,5,4,1,1,1,1,4,1,1,3,5,4,3,1,1,5,4,1,1,2,5,4,2,1,4,1,1,1,1,3,1,1,1,1,4,1,1,1,1,2,4,1,1,1,1,3,1,1,5,1,1,1,1,1,1,4,2,1,3,1,1,1,2,4,2,3,1,4,1,2,1,4,2,1,4,4,1,5,1,1,4,4,1,2,2,1,1,1,1,1,1,1,1,1,1,1,4,5,4,1,3,1,3,1,1,1,5,3,5,5,2,2,1,4,1,4,2,1,4,1,2,1,1,2,1,1,5,4,2,1,1,1,2,4,1,1,1,1,2,1,1,5,1,1,2,2,5,1,1,1,1,1,2,4,2,3,1,2,1,5,4,5,1,4`.split(\"\\n\")\r\n    );\r\n}\r\n","const find4 = (x, y, matrix, wantedChar) => {\n  wantedChar = wantedChar || 1;\n  let returnable = [];\n  if (x > 0 && x < matrix[y].length - 1) {\n    matrix[y][x - 1] === wantedChar\n      ? returnable.push({x: x - 1, y: y})\n      : false;\n    matrix[y][x + 1] === wantedChar\n      ? returnable.push({x: x + 1, y: y})\n      : false;\n  } else if (x === 0) {\n    matrix[y][x + 1] === wantedChar\n      ? returnable.push({x: x + 1, y: y})\n      : false;\n  } else if (x === matrix[y].length - 1) {\n    matrix[y][x - 1] === wantedChar\n      ? returnable.push({x: x - 1, y: y})\n      : false;\n  }\n  if (y > 0 && y < matrix.length - 1) {\n    matrix[y + 1][x] === wantedChar\n      ? returnable.push({x: x, y: y + 1})\n      : false;\n    matrix[y - 1][x] === wantedChar\n      ? returnable.push({x: x, y: y - 1})\n      : false;\n  } else if (y === 0) {\n    matrix[y + 1][x] === wantedChar\n      ? returnable.push({x: x, y: y + 1})\n      : false;\n  } else if (y === matrix.length - 1) {\n    matrix[y - 1][x] === wantedChar\n      ? returnable.push({x: x, y: y - 1})\n      : false;\n  }\n  return returnable;\n};\n\nconst get8 = (x, y, matrix) => {\n  const positions = [\n    {y: y - 1, x: x - 1},\n    {y: y - 1, x: x},\n    {y: y - 1, x: x + 1},\n    {y: y, x: x + 1},\n    {y: y + 1, x: x + 1},\n    {y: y + 1, x: x},\n    {y: y + 1, x: x - 1},\n    {y: y, x: x - 1},\n  ]\n  const returnable = [];\n  positions.forEach(pos =>\n    matrix[pos.y] === undefined ? \"\" :\n      matrix[pos.y][pos.x] === undefined ? \"\" :\n        returnable\n          .push(matrix[pos.y][pos.x]));\n  return returnable;\n}\n\n\n\nconst num2letter = chr => String.fromCharCode(97 + chr);\n\nconst hex2bin = (hex, nulls) => {\n  const nullAmount = nulls || 4;\n  return (\n    [...Array(nullAmount)].map(e => \"0\").join(\"\") +\n    parseInt(hex, 16).toString(2)\n  ).substr(-nullAmount);\n};\n\nconst num2hex = num => num.toString(16);\n\nconst dec2bin = num => (num >>> 0).toString(2)\n\nconst bin2dec = binary => parseInt(binary, 2);\n\nconst swapPositions = (arr, index1, index2) => (\n  //console.log(arr, index1, index2),\n  ([arr[index1], arr[index2]] = [arr[index2], arr[index1]]), arr\n);\n\nconst insertValueAtMutating = (arr, index, newValue) => {\n  arr\n    .splice(index, 1, newValue);\n  // .map(e => e.map ? e.map(i => i) : e) //clone\n  return arr\n}\n\nconst arrayRotate = (arr, reverse) => (\n  reverse ? arr.unshift(arr.pop()) : arr.push(arr.shift()), arr\n);\n\nconst arrayRotateLeft = (arr) => (\n  arr.push(arr.shift()), arr\n);\nconst arrayRotateRight = (arr) => (\n  arr.unshift(arr.pop()), arr\n);\n\nconst trampoline = fn => {\n  while (typeof fn === \"function\") {\n    fn = fn();\n  }\n  return fn;\n};\n\nconst uniqueShallow = (item, i, arr) => !arr.slice(i + 1).includes(item);\n\nconst uniqueDeep = (item, i, arr) =>\n  !arr\n    .slice(i + 1)\n    .some(other => JSON.stringify(other) === JSON.stringify(item));\n\nconst combineMatrices = (larger, smaller) =>\n  larger\n    //clone\n    .map(e => e.map(i => i))\n    .map((largerLine, lineNum) => {\n      const startPoint = Math.floor(\n        (largerLine.length - smaller[0].length) / 2\n      );\n      if (lineNum >= startPoint && lineNum < larger.length - startPoint) {\n        return largerLine.map((char, charNum) => {\n          if (\n            charNum >= startPoint &&\n            charNum < largerLine.length - startPoint\n          ) {\n            return smaller[lineNum - startPoint][charNum - startPoint];\n          } else {\n            return char;\n          }\n        });\n      } else {\n        return largerLine;\n      }\n    });\n\nconst flatten = arr =>\n  arr.reduce(\n    (flat, toFlatten) =>\n      flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten),\n    []\n  );\n\nconst insert = function (array, i, ...rest) {\n  return array.slice(0, i).concat(rest, array.slice(i));\n}\n\nconst reduceSum = (acc, next) =>\n  acc + next;\n\nconst reduceMultiply = (acc, next) =>\n  acc * next;\n\nconst reduceFlatten = (acc, next) =>\n  acc.concat(next);\n\n\nconst permutations = xs => {\n  let ret = [];\n\n  for (let i = 0; i < xs.length; i = i + 1) {\n    let rest = permutations(xs.slice(0, i).concat(xs.slice(i + 1)));\n\n    if (!rest.length) {\n      ret.push([xs[i]])\n    } else {\n      for (let j = 0; j < rest.length; j = j + 1) {\n        ret.push([xs[i]].concat(rest[j]))\n      }\n    }\n  }\n  return ret;\n}\n\nconst returnUniqueAmountsAsObj = array =>\n  array.reduce((acc, val) => {  //amounts as an object\n    acc[val] = acc[val] === undefined ? 1 : acc[val] += 1;\n    return acc;\n  }, {});\n\nconst betweenOrEqual = (number, min, max) =>\n  number >= min && number <= max\n\nfunction gcd2(a, b) {\n  // Greatest common divisor of 2 integers\n  if (!b) return b === 0 ? a : NaN;\n  return gcd2(b, a % b);\n}\nfunction gcd(array) {\n  // Greatest common divisor of a list of integers\n  var n = 0;\n  for (var i = 0; i < array.length; ++i)\n    n = gcd2(array[i], n);\n  return n;\n}\nfunction lcm2(a, b) {\n  // Least common multiple of 2 integers\n  return a * b / gcd2(a, b);\n}\nfunction lcm(array) {\n  // Least common multiple of a list of integers\n  var n = 1;\n  for (var i = 0; i < array.length; ++i)\n    n = lcm2(array[i], n);\n  return n;\n}\nfunction mostFrequentElems(array) {\n  const mostCommon = array\n    .filter(uniqueShallow)\n    .sort((a, b) =>\n      array\n        .filter(e => e === b).length - array.filter(e => e === a).length)[0];\n\n  const mostCommonLength =\n    array.filter(e => e === mostCommon).length\n\n  return array\n    .filter(e => array.filter(another => another === e).length === mostCommonLength)\n    .filter(uniqueShallow)\n}\n\nconst transpose = m => m[0].map((x, i) => m.map(x => x[i]))\n\n\nexport {\n  find4,\n  get8,\n  num2letter,\n  hex2bin,\n  num2hex,\n  dec2bin,\n  bin2dec,\n  swapPositions,\n  insertValueAtMutating,\n  arrayRotate,\n  arrayRotateLeft,\n  arrayRotateRight,\n  trampoline,\n  uniqueShallow,\n  uniqueDeep,\n  combineMatrices,\n  flatten,\n  insert,\n  reduceSum,\n  reduceMultiply,\n  reduceFlatten,\n  permutations,\n  returnUniqueAmountsAsObj,\n  betweenOrEqual,\n  lcm,\n  gcd,\n  mostFrequentElems,\n  transpose\n}"],"names":["$3c8f1a1c09db7dbb$var$log","args","console","document","log","querySelector","innerHTML","join","$3c8f1a1c09db7dbb$var$getInput","length","$3c8f1a1c09db7dbb$var$getTESTInput","$3c8f1a1c09db7dbb$var$inputArr","$3c8f1a1c09db7dbb$var$advanceNumDays","list","dayLimit","day","newChildrenMutating","map","lanternfish","push","concat","$3c8f1a1c09db7dbb$var$advanceNumDaysForB","listObj","JSON","stringify","tempValueFor8","Object","keys","forEach","key","i","parseInt","$3c8f1a1c09db7dbb$var$arrInUse","split","e","$3c8f1a1c09db7dbb$var$objForB","reduce","acc","val","undefined","values","next"],"version":3,"file":"index.js.map"}