{"mappings":"eAISA,KAAOC,GACa,oBAAbC,SAAkD,oBAAdC,WAC5CD,QAAQE,OAAOH,GACfE,SAASE,cAAc,OAAQC,WAAa,QAAUL,EAAKM,KAAK,MANxEL,QAAQE,IAAII,IAAWC,QACvBP,QAAQE,IAAIM,IAAeD,QASEC,IACJF,IADzB,MAUMG,EAAO,CACTC,EACAC,EAAoB,EACpBC,EAAoB,EACpBC,EAAuB,KACvB,IAAKF,EACD,OAAOE,EACX,MAAMC,EAAgD,GAChDC,EACFL,EAAMM,KAAG,CAAEC,EAAgBC,IACvBD,EAAKD,KAAG,CAAEG,EAAmBC,IAAsBD,EAAY,MAOvE,OALAE,EACIN,EACAD,GACAA,EAAkBP,SAAWG,EAAMH,OAASG,EAAM,GAAGH,QACrDT,EAAI,KAAMc,EAAY,GACnBH,EAAQM,EAAUJ,EAAY,EAAGC,EAAY,EAAGC,EAAeC,EAAkBP,SAItFc,EAAU,CAAIX,EAAmBY,EAA6C,MAChFZ,EAAMa,SAAO,CAAEN,EAAgBC,IAC3BD,EAAKM,SAAO,CAAEJ,EAAmBC,KACzBD,EAAY,GAAKG,EAAeE,OAAMC,GAAMA,EAAGL,IAAMA,GAAKK,EAAGP,IAAMA,MACnER,EAAMQ,GAAGE,GAAK,EACdE,EAAeI,KAAK,CAAEN,EAAGA,EAAGF,EAAGA,ICW5B,EAAIE,EAAGF,EAAGS,KAC3B,MAWMC,EAAa,GAMnB,MAhBE,CACE,CAACV,EAAGA,EAAI,EAAGE,EAAGA,EAAI,GAClB,CAACF,EAAGA,EAAI,EAAGE,EAAGA,GACd,CAACF,EAAGA,EAAI,EAAGE,EAAGA,EAAI,GAClB,CAACF,EAAGA,EAAGE,EAAGA,EAAI,GACd,CAACF,EAAGA,EAAI,EAAGE,EAAGA,EAAI,GAClB,CAACF,EAAGA,EAAI,EAAGE,EAAGA,GACd,CAACF,EAAGA,EAAI,EAAGE,EAAGA,EAAI,GAClB,CAACF,EAAGA,EAAGE,EAAGA,EAAI,IAGRG,SAAQM,QACEC,IAAlBH,EAAOE,EAAIX,SACgBY,IAAzBH,EAAOE,EAAIX,GAAGW,EAAIT,GADU,GAE1BQ,EACGF,KAAKG,KACPD,GD5BOG,CAAcX,EAAGF,EAAGR,GACfa,SAAO,CAAES,EAA+BC,EAAGC,KACpCZ,EAAeE,OAAMC,GAAMA,EAAGL,IAAMY,EAAIZ,GAAKK,EAAGP,IAAMc,EAAId,MAC1DR,EAAMsB,EAAId,GAAGc,EAAIZ,IAAM,GAC3BC,EAAWX,EAAOY,YAO/BZ,GAMLyB,EACF7B,aAoCAE,IAaH,MAAA,qQA/CDV,EAAI,KAGAW,EAAmB0B,EAtDdC,MAAM,MACNpB,KAAKC,GAAiBA,EAAKmB,MAAM,IAAIpB,KAAKqB,GAAwBC,SAASD,OAqDlD","sources":["src/index.ts","../../helpmodule.js"],"sourcesContent":["import { get8Positions, range } from \"../../../helpmodule.js\";\r\nconsole.log(getInput().length);\r\nconsole.log(getTESTInput().length);\r\n\r\nfunction log(...args: any[]): void {\r\n    if (typeof (console) !== 'undefined' && typeof (document) !== 'undefined') {\r\n        console.log(...args);\r\n        document.querySelector('pre')!.innerHTML += \"<br/>\" + args.join(\" \");\r\n    }\r\n}\r\n\r\nconst testInputArr: string = getTESTInput();\r\nconst inputArr: string = getInput();\r\n\r\n\r\nconst parseInput = (input: string): number[][] =>\r\n    input\r\n        .split(\"\\n\")\r\n        .map((line: string) => line.split(\"\").map((chr: string): number => parseInt(chr)))\r\n\r\n\r\nconst doSteps = (\r\n    input: number[][],\r\n    stepsLeft: number = 1,\r\n    stepsDone: number = 0,\r\n    totalFlashes: number = 0): number => {\r\n    if (!stepsLeft)\r\n        return totalFlashes;\r\n    const alreadyFlashedArr: { x: number, y: number }[] = [];\r\n    const newInput =\r\n        input.map((line: number[], y: number): number[] =>\r\n            line.map((octopussy: number, x: number): number => octopussy + 1))\r\n\r\n    doFlashing(\r\n        newInput,\r\n        alreadyFlashedArr)\r\n    if (alreadyFlashedArr.length === input.length * input[0].length)\r\n        log(\"b:\", stepsDone + 1)\r\n    return doSteps(newInput, stepsLeft - 1, stepsDone + 1, totalFlashes + alreadyFlashedArr.length)\r\n\r\n}\r\n\r\nconst doFlashing = (input: number[][], alreadyFlashed: { x: number, y: number }[] = []): number[][] => {\r\n    input.forEach((line: number[], y) =>\r\n        line.forEach((octopussy: number, x) => {\r\n            if (octopussy > 9 && alreadyFlashed.every(el => el.x !== x || el.y !== y)) {\r\n                input[y][x] = 0;\r\n                alreadyFlashed.push({ x: x, y: y })\r\n                get8Positions(x, y, input)\r\n                    .forEach((obj: { x: number, y: number }, i, arr) => {\r\n                        if (alreadyFlashed.every(el => el.x !== obj.x || el.y !== obj.y))\r\n                            input[obj.y][obj.x] += 1\r\n                        doFlashing(input, alreadyFlashed)\r\n                    })\r\n            }\r\n        }\r\n        )\r\n    )\r\n\r\n    return input\r\n}\r\n\r\n\r\n\r\n\r\nconst arrInUse =\r\n    getInput();\r\n\r\nlog(\"a:\",\r\n\r\n\r\n    doSteps(parseInput(arrInUse), 500)\r\n    // .map(line => line.join(\"\")).join(\"\\n\")\r\n)\r\n\r\n\r\n\r\nfunction getMiniTESTInput(): string {\r\n    return (\r\n        `11111\r\n19991\r\n19191\r\n19991\r\n11111`\r\n    )\r\n};\r\n\r\nfunction getTESTInput(): string {\r\n    return (\r\n        `5483143223\r\n2745854711\r\n5264556173\r\n6141336146\r\n6357385478\r\n4167524645\r\n2176841721\r\n6882881134\r\n4846848554\r\n5283751526`)\r\n}\r\n\r\nfunction getInput(): string {\r\n    return (\r\n\r\n        `8624818384\r\n3725473343\r\n6618341827\r\n4573826616\r\n8357322142\r\n6846358317\r\n7286886112\r\n8138685117\r\n6161124267\r\n3848415383`\r\n    );\r\n}\r\n","const find4 = (x, y, matrix, wantedChar) => {\n  wantedChar = wantedChar || 1;\n  let returnable = [];\n  if (x > 0 && x < matrix[y].length - 1) {\n    matrix[y][x - 1] === wantedChar\n      ? returnable.push({x: x - 1, y: y})\n      : false;\n    matrix[y][x + 1] === wantedChar\n      ? returnable.push({x: x + 1, y: y})\n      : false;\n  } else if (x === 0) {\n    matrix[y][x + 1] === wantedChar\n      ? returnable.push({x: x + 1, y: y})\n      : false;\n  } else if (x === matrix[y].length - 1) {\n    matrix[y][x - 1] === wantedChar\n      ? returnable.push({x: x - 1, y: y})\n      : false;\n  }\n  if (y > 0 && y < matrix.length - 1) {\n    matrix[y + 1][x] === wantedChar\n      ? returnable.push({x: x, y: y + 1})\n      : false;\n    matrix[y - 1][x] === wantedChar\n      ? returnable.push({x: x, y: y - 1})\n      : false;\n  } else if (y === 0) {\n    matrix[y + 1][x] === wantedChar\n      ? returnable.push({x: x, y: y + 1})\n      : false;\n  } else if (y === matrix.length - 1) {\n    matrix[y - 1][x] === wantedChar\n      ? returnable.push({x: x, y: y - 1})\n      : false;\n  }\n  return returnable;\n};\n\nconst get8 = (x, y, matrix) => {\n  const positions = [\n    {y: y - 1, x: x - 1},\n    {y: y - 1, x: x},\n    {y: y - 1, x: x + 1},\n    {y: y, x: x + 1},\n    {y: y + 1, x: x + 1},\n    {y: y + 1, x: x},\n    {y: y + 1, x: x - 1},\n    {y: y, x: x - 1},\n  ]\n  const returnable = [];\n  positions.forEach(pos =>\n    matrix[pos.y] === undefined ? \"\" :\n      matrix[pos.y][pos.x] === undefined ? \"\" :\n        returnable\n          .push(matrix[pos.y][pos.x]));\n  return returnable;\n}\n\nconst get8Positions = (x, y, matrix) => {\n  const positions =\n    [\n      {y: y - 1, x: x - 1},\n      {y: y - 1, x: x},\n      {y: y - 1, x: x + 1},\n      {y: y, x: x + 1},\n      {y: y + 1, x: x + 1},\n      {y: y + 1, x: x},\n      {y: y + 1, x: x - 1},\n      {y: y, x: x - 1},\n    ]\n  const returnable = [];\n  positions.forEach(pos =>\n    matrix[pos.y] === undefined ? \"\" :\n      matrix[pos.y][pos.x] === undefined ? \"\" :\n        returnable\n          .push(pos));\n  return returnable\n\n}\n\nconst num2letter = chr => String.fromCharCode(97 + chr);\n\nconst hex2bin = (hex, nulls) => {\n  const nullAmount = nulls || 4;\n  return (\n    [...Array(nullAmount)].map(e => \"0\").join(\"\") +\n    parseInt(hex, 16).toString(2)\n  ).substr(-nullAmount);\n};\n\nconst num2hex = num => num.toString(16);\n\nconst dec2bin = num => (num >>> 0).toString(2)\n\nconst bin2dec = binary => parseInt(binary, 2);\n\nconst swapPositions = (arr, index1, index2) => (\n  //console.log(arr, index1, index2),\n  ([arr[index1], arr[index2]] = [arr[index2], arr[index1]]), arr\n);\n\nconst insertValueAtMutating = (arr, index, newValue) => {\n  arr\n    .splice(index, 1, newValue);\n  // .map(e => e.map ? e.map(i => i) : e) //clone\n  return arr\n}\n\nconst arrayRotate = (arr, reverse) => (\n  reverse ? arr.unshift(arr.pop()) : arr.push(arr.shift()), arr\n);\n\nconst arrayRotateLeft = (arr) => (\n  arr.push(arr.shift()), arr\n);\nconst arrayRotateRight = (arr) => (\n  arr.unshift(arr.pop()), arr\n);\n\nconst trampoline = fn => {\n  while (typeof fn === \"function\") {\n    fn = fn();\n  }\n  return fn;\n};\n\nconst uniqueShallow = (item, i, arr) => !arr.slice(i + 1).includes(item);\n\nconst uniqueDeep = (item, i, arr) =>\n  !arr\n    .slice(i + 1)\n    .some(other => JSON.stringify(other) === JSON.stringify(item));\n\nconst combineMatrices = (larger, smaller) =>\n  larger\n    //clone\n    .map(e => e.map(i => i))\n    .map((largerLine, lineNum) => {\n      const startPoint = Math.floor(\n        (largerLine.length - smaller[0].length) / 2\n      );\n      if (lineNum >= startPoint && lineNum < larger.length - startPoint) {\n        return largerLine.map((char, charNum) => {\n          if (\n            charNum >= startPoint &&\n            charNum < largerLine.length - startPoint\n          ) {\n            return smaller[lineNum - startPoint][charNum - startPoint];\n          } else {\n            return char;\n          }\n        });\n      } else {\n        return largerLine;\n      }\n    });\n\nconst flatten = arr =>\n  arr.reduce(\n    (flat, toFlatten) =>\n      flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten),\n    []\n  );\n\nconst insert = function (array, i, ...rest) {\n  return array.slice(0, i).concat(rest, array.slice(i));\n}\n\nconst reduceSum = (acc, next) =>\n  acc + next;\n\nconst reduceMultiply = (acc, next) =>\n  acc * next;\n\nconst reduceFlatten = (acc, next) =>\n  acc.concat(next);\n\n\nconst permutations = xs => {\n  let ret = [];\n\n  for (let i = 0; i < xs.length; i = i + 1) {\n    let rest = permutations(xs.slice(0, i).concat(xs.slice(i + 1)));\n\n    if (!rest.length) {\n      ret.push([xs[i]])\n    } else {\n      for (let j = 0; j < rest.length; j = j + 1) {\n        ret.push([xs[i]].concat(rest[j]))\n      }\n    }\n  }\n  return ret;\n}\n\nconst returnUniqueAmountsAsObj = array =>\n  array.reduce((acc, val) => {  //amounts as an object\n    acc[val] = acc[val] === undefined ? 1 : acc[val] += 1;\n    return acc;\n  }, {});\n\nconst betweenOrEqual = (number, min, max) =>\n  number >= min && number <= max\n\nfunction gcd2(a, b) {\n  // Greatest common divisor of 2 integers\n  if (!b) return b === 0 ? a : NaN;\n  return gcd2(b, a % b);\n}\nfunction gcd(array) {\n  // Greatest common divisor of a list of integers\n  var n = 0;\n  for (var i = 0; i < array.length; ++i)\n    n = gcd2(array[i], n);\n  return n;\n}\nfunction lcm2(a, b) {\n  // Least common multiple of 2 integers\n  return a * b / gcd2(a, b);\n}\nfunction lcm(array) {\n  // Least common multiple of a list of integers\n  var n = 1;\n  for (var i = 0; i < array.length; ++i)\n    n = lcm2(array[i], n);\n  return n;\n}\nfunction mostFrequentElems(array) {\n  const mostCommon = array\n    .filter(uniqueShallow)\n    .sort((a, b) =>\n      array\n        .filter(e => e === b).length - array.filter(e => e === a).length)[0];\n\n  const mostCommonLength =\n    array.filter(e => e === mostCommon).length\n\n  return array\n    .filter(e => array.filter(another => another === e).length === mostCommonLength)\n    .filter(uniqueShallow)\n}\n\nconst transpose = m => m[0].map((x, i) => m.map(x => x[i]))\n\nconst range = (start, stop, step = 1) =>\n  Array.from({length: (stop - start) / step + 1}, (_, i) => start + (i * step));\n\n\n\nexport {\n  find4,\n  get8,\n  get8Positions,\n  num2letter,\n  hex2bin,\n  num2hex,\n  dec2bin,\n  bin2dec,\n  swapPositions,\n  insertValueAtMutating,\n  arrayRotate,\n  arrayRotateLeft,\n  arrayRotateRight,\n  trampoline,\n  uniqueShallow,\n  uniqueDeep,\n  combineMatrices,\n  flatten,\n  insert,\n  reduceSum,\n  reduceMultiply,\n  reduceFlatten,\n  permutations,\n  returnUniqueAmountsAsObj,\n  betweenOrEqual,\n  lcm,\n  gcd,\n  mostFrequentElems,\n  transpose,\n  range\n}"],"names":["$3c8f1a1c09db7dbb$var$log","args","console","document","log","querySelector","innerHTML","join","$3c8f1a1c09db7dbb$var$getInput","length","$3c8f1a1c09db7dbb$var$getTESTInput","$3c8f1a1c09db7dbb$var$doSteps","input","stepsLeft","stepsDone","totalFlashes","alreadyFlashedArr","newInput","map","line","y","octopussy","x","$3c8f1a1c09db7dbb$var$doFlashing","alreadyFlashed","forEach","every","el","push","matrix","returnable","pos","undefined","$f5543be055ba0b53$export$72a6be7e1236ce7b","obj","i","arr","$3c8f1a1c09db7dbb$var$arrInUse","split","chr","parseInt"],"version":3,"file":"index.js.map"}